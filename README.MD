## üê≥ Docker

1. Instalar `docker descktop`
2. Verificar a instala√ß√£o `docker -v`
3. Ver informa√ß√µes do Docker `docker info`
4. Baixar uma imagem de teste `docker pull hello-world`
5. Rodar um container `docker run hello-world`
6. Listar imagens baixadas `docker images`
7. Ver containers em execu√ß√£o `docker ps`
8. Iniciar um container parado `docker start <container_id>`
9. 9. Utilizando Docker Compose
   - üìÑ docker-compose.yml
     - O docker-compose.yml √© um arquivo de configura√ß√£o no formato YAML usado pelo Docker       Compose para definir e gerenciar aplica√ß√µes com m√∫ltiplos containers.
     - Ele permite:
     - Definir servi√ßos (API, banco, etc)
     - Configurar redes
     - Criar volumes
     - üëâ Com um √∫nico comando voc√™ sobe tudo:
     - `docker compose up -d`
10. Banco de dados PostgreSQL Utilizar a imagem: `bitnami/postgresql`
11. Banco de dados redis Utilizar a imagem: `bitnami/redis`
12. Ver contairnes ativos final `docker ps`


## üì¶ Dependencies

1. fastify
2. tsx -D (npx tsx --init)
3. typescript -D
4. @types/node -D
5. @fastify/cors
6. zod
7. fastify-type-provider-zod
8. @fastify/swagger
9. @fastify/swagger-ui
10. @biomejs/biome -D
11. ioredis
12. postgres
13. drizzle-orm
14. drizzle-kit -D


## ‚öôÔ∏è Config

1. Configura√ß√£o de cors, deixando origin: true, em ambiente de dev, para todas urls front usem a api
2. Em produ√ß√£o mudar para a nossa URL do front-end


## üõ°Ô∏è Zod

1. import { validatorCompiler, serializerCompiler, ZodTypeProvider } from "fastify-type-provider-zod"
  - validatorCompiler Determina qual que √© o formato de entrada de dados em cada rota
  - serializerCompiler E a forma de transformar os dados na hora de enviar ao front-end
  - app.setValidatorCompiler(validatorCompiler);
  - app.setSerializerCompiler(serializerCompiler);
2. Valida√ß√£o automaticamente
3. Tipar o body da nossa requisi√ß√£o post / put
   - Usando o schema
   - Passando o Body 
   - Definindo o z.object
   - E dentro do objeto definimos a tipagem que esparamos receber
   - Na instancia do fastify usamos isso .withTypeProvider<ZodTypeProvider>()

4. Types 
   - `z.string()` ‚Üí valida que o valor √© uma string
   - `z.number()` ‚Üí valida que o valor √© um n√∫mero
   - `z.boolean()` ‚Üí valida true ou false
   - `z.object()` ‚Üí valida um objeto com estrutura definida
   - `z.array()` ‚Üí valida uma lista (array) de valores
   - `z.enum()` ‚Üí valida valores fixos (ex: "admin" | "user")
   - `z.optional()` ‚Üí torna o campo opcional (pode n√£o existir)
   - `z.nullable()` ‚Üí permite que o valor seja null
   - `z.nullish()` ‚Üí permite null ou undefined
   - `z.string().email()` ‚Üí valida se √© um email v√°lido
   - `z.string().url()` ‚Üí valida se √© uma URL v√°lida
   - `z.string().uuid()` ‚Üí valida se √© um UUID v√°lido
   - `z.string().min()/max()` ‚Üí define tamanho m√≠nimo/m√°ximo de string
   - `z.number().min()/max()` ‚Üí define valor m√≠nimo/m√°ximo num√©rico
   - `z.coerce.string()` ‚Üí converte automaticamente o valor para string antes de validar
   - `z.coerce.number()` ‚Üí converte automaticamente para n√∫mero (ex: "10" ‚Üí 10)
   - `z.coerce.boolean()` ‚Üí converte valores para boolean (ex: "true" ‚Üí true)
   - `z.coerce.date()` ‚Üí converte para Date (ex: string de data ‚Üí objeto Date)



## üåê Testing API Routes

1. Baixar a insten√ß√£o REST Client
2. Exemplo simples de POST
   ```
   POST http://localhost:3333/subscriptions
   Content-Type: application/json

    {
        "name": "Unfast uk",
        "email": "unfastuk123@gmail.com"
   }


## üìÉ Doc API com swagger

1. Utilizar o @fastify/swagger e @fastify/swagger-ui
2. Exemplo de uso
```
import { fastifySwagger } from "@fastify/swagger"
import { fastifySwaggerUi } from "@fastify/swagger-ui"
import { jsonSchemaTransform } from "fastify-type-provider-zod"

app.register(fastifySwagger, {
    openapi: {
        info: {
            title: "Fastify API",
            description: "API documentation",
            version: "0.1.0"
        }
    },
    transform: jsonSchemaTransform
})

app.register(fastifySwaggerUi, { routePrefix: "/docs" })
```


## Exemplo de rota com fastify + zod

1. no server.ts
   - const app = fastify().withTypeProvider<ZodTypeProvider>()
   - app.register(fastifyCors, { origin: true })
   - app.setValidatorCompiler(validatorCompiler);
   - app.setSerializerCompiler(serializerCompiler);

2. Vincular a rota
   - app.register(subscribeToEventRoute)

3. No arquivo da rota, criar uma fun√ß√£o, recebendo um parametro (app), utilizando a tipagem FastifyPluginAsyncZod
   - O Fastify automaticamente:
   - Usa o validatorCompiler (Zod)
   - Usa o serializerCompiler
   - Aplica os tipos no request.body
   - Aplica os tipos no reply
   - ‚úîÔ∏è O que aconteceu foi:
   -   - Voc√™ configurou o Fastify globalmente
   -   - A rota recebe esse Fastify j√° configurado
   -   - Ent√£o ela automaticamente ganha tipagem + valida√ß√£o
  
  ```
  
  import { z } from "zod"
  import { FastifyPluginAsyncZod } from "fastify-type-provider-zod"

  export const subscribeToEventRoute: FastifyPluginAsyncZod = async (app) => {

    app.post("/subscriptions", {
        schema: {
            summary: "Subscribe to an event",
            tags: ["Subscription"],
            description: "Subscribe to an event",
            body: z.object({
                name: z.string(),
                email: z.email()
            }),
            response: {
                201: z.object({
                    name: z.string(),
                    email: z.email()
                })
            }
        }
    }, async (request, reply) => {
        const { name, email } = request.body

        return reply.status(201).send({ name, email })
    })
  }
  ```

## üîè ENV

1. O node por padr√£o ja consegue ler vari√°veis de ambiente
   - ```  "dev": "tsx watch --env-file=.env src/server.ts"  ```

2. Criar um arquivo para a valida√ß√£o / cria√ß√£o de schema para as vari√°veis de ambiente
   - no lugar de ``` app.listen({ port: 3333 }) ```
   - Use ``` app.listen({ port: env.PORT }) ```

```
import { z } from 'zod'

const envSchema = z.object({
   PORT: z.coerce.number().default(3333),
   POSTGRES_URL: z.url(),
   REDIS_URL: z.url(),
   WEB_URL: z.url(),
})

export const env = envSchema.parse(process.env)

```


## Biomejs 
1. √© uma ferramenta de desenvolvimento moderna, r√°pida e "tudo em um" (all-in-one) projetada para projetos web, funcionando como um substituto de alto desempenho para o ESLint e o Prettier. Escrito em Rust, ele oferece formata√ß√£o de c√≥digo e an√°lise est√°tica (linting) para JavaScript, TypeScript, JSX, JSON, CSS e GraphQL com uma velocidade significativamente superior √†s ferramentas tradicionais baseadas em JavaScript. 
   
2. Instalar a extens√£o do Biome
3. Baixar a lib em desenvolvimento no projeto ```@biomejs/biome -D```
4. Dentro do Projeto criar uma pasta .vscode
   - um arquivo settings.json
```
{
  "editor.formatOnSave": true,
  "[typescript]": {
    "editor.defaultFormatter": "biomejs.biome"
  },
  "editor.codeActionsOnSave": {
    "source.organizeImports.biome": "explicit"
  }
}
```

5. Criar um Biome.json
```
{
  "$schema": "./node_modules/@biomejs/biome/configuration_schema.json",

   "formatter": {
    "enabled": true,
    "indentStyle": "space",
    "indentWidth": 2,
    "lineWidth": 80
  },

  "javascript": {
    "formatter": {
      "quoteStyle": "single",
      "jsxQuoteStyle": "double",
      "trailingCommas": "all",
      "semicolons": "asNeeded",
      "arrowParentheses": "asNeeded",
      "bracketSpacing": true
    }
  },

  "linter": {
    "enabled": true,
    "rules": {
      "recommended": true
    }
  }

}
```


## ‚ö° Redis

1. Criar uma pasta redis, com um arquivo clinet.ts para fazer a conex√£p
2. Instalar a lib ioredis
3. Conex√£o
4. Metodos
   - `redis.hincrby(...)` üëâ Incrementa um n√∫mero dentro de um hash no Redis
   - `redis.hget(...)` üëâ Busca o valor de um campo espec√≠fico dentro de um hash no Redis
   - `redis.zincrby(...)` üëâ Incrementa a pontua√ß√£o (score) de um membro em um Sorted Set (ranking)
   - `redis.zscore` üëâ Retorna a pontua√ß√£o (score) atual de um membro dentro do Sorted Set
   - `redis.zrevrank(...)` üëâ Retorna a posi√ß√£o do usu√°rio no ranking (ordem decrescente)
```
import { Redis } from 'ioredis'
import { env } from '../env'

export const redis = new Redis(env.REDIS_URL)

```

## üêò PostgreSQL

1. Banco de dados relacional
2. Consultar via SQL
3. por√©m utilizaremos uma orm chamda drizzle
4. Facilitar as querys no banco, no lugar de escrever sql na m√£o
5. Conex√£o via postgres + drizzle (orm)
```
import { drizzle } from 'drizzle-orm/postgres-js'
import postgres from 'postgres'
import { env } from '../env'
import { subscriptions } from './schema/subscriptions'

export const pg = postgres(env.POSTGRES_URL)
export const db = drizzle(pg, {
  schema: {
    subscriptions,
  },
})


```



## üß© Drizzle

1. √© um mapeador objeto-relacional (ORM) leve e moderno, focado em TypeScript e SQL, projetado para ser intuitivo e perform√°tico
2. Ele funciona como uma camada fina sobre o banco de dados, permitindo que os desenvolvedores escrevam consultas SQL reais e seguras (type-safe) sem a complexidade de ORMs mais pesados, oferecendo excelente suporte a dialetos como PostgreSQL, MySQL e SQLite. 

3. Cria√ß√£o de Schemas
   - Criar uma pasta Schema e um arquivo para cada tabela
   - Utilizar o `pgTable` para a cria√ß√£o da tabela, definindo um nome como parametro, e um objeto para os elementos da tabela
   - `.uui()` define a coluna como UUID (identificador √∫nico).
    - `.primaryKey()` marca essa coluna como chave prim√°ria da tabela.
    - `.defaultRandom()` gera automaticamente um UUID aleat√≥rio ao inserir um novo registro.
    - `.notNull()` obriga que essa coluna sempre tenha valor (n√£o pode ser null).
   - `.unique()` garante que n√£o existam valores repetidos nessa coluna (ex: e-mail √∫nico)
   - `timestamp("created_at")` cria uma coluna de data/hora.
   - `.defaultNow()` define automaticamente a data/hora atual ao criar o registro.


```
import { pgTable, text, timestamp, uuid } from 'drizzle-orm/pg-core'

export const subscriptions = pgTable('subscriptions', {
   id: uuid('id').primaryKey().defaultRandom(),
   name: text('name').notNull(),
   email: text('email').notNull().unique(),
   createdAt: timestamp("created_at").notNull().defaultNow(),
})

export type Subscription = typeof subscriptions

```

4. Criar realmente a tabela no nosso banco de dados
5. Criar um arquivo na raiz drizzle.config.ts
   - Utilizar o Config do `drizzle-kit` ‚Üí importa s√≥ o tipo de configura√ß√£o do Drizzle (n√£o vai pro runtime).
   - `import { env }` ‚Üí importa as vari√°veis de ambiente (URL do banco).
   - Utilizar um export default passando um objeto com algumas propiedades
      - `schema:`: `"./src/drizzle/schema/*"`  ‚Üí caminho onde est√£o os arquivos das tabelas.
      - `out`: `"./src/drizzle/migrations"` ‚Üí pasta onde ser√£o geradas as migrations.
      - `dialect`: `'postgresql'` ‚Üí define o banco usado (PostgreSQL).
      - `dbCredentials`: `{ url:  env.POSTGRES_URL}` ‚Üí garante que o objeto segue o padr√£o correto do Drizzle.


```
import type { Config } from 'drizzle-kit' 
import { env } from './src/env'

export default {
  schema: './src/drizzle/schema/*',
  out: './src/drizzle/migrations',
  dialect: 'postgresql',
  dbCredentials: {
    url: env.POSTGRES_URL,
  },
} satisfies Config

```

6. Rodar o comando `npx drizzle-kit generate` ‚Üí gera o arquivo de migration com base nas mudan√ßas do schema.
7. Rodar o comando `npx drizzle-kit migrate`  ‚Üí aplica as migrations no banco de dados.
8. querys com Drizzle e seus metodos
```
Example Basic query 

    const subscribers = await db.select()
        .from(subscriptions)
        .where(eq(subscriptions.email, email))

```
  - `select()` ‚Üí Define quais dados/colunas voc√™ quer buscar no banco
  - `from()` ‚Üí Define de qual tabela os dados ser√£o buscados
  - `where()` ‚Üí Aplica um filtro na consulta
  - `eq()` ‚Üí Compara se um campo √© igual a um valor (= no SQL)

## Funcionalidades da nossa aplica√ß√£o

1. Criar dentro de src uma pasta functions 
2. Passando o nome de cada funcionalidade 

3. A primeira √© a Realiza√ß√£o de uma nova inscri√ß√£o pelo us√∫ario
   - Criar um arquivo chamado `subscribe-to-event-route.ts`
   - Criar uma interface passando o name e email
   - Criar uma fun√ß√£o asyncrona passando os parametros e a tipagem
   - Criar uma variavel result, utilizando o await e com o `db` utlizar o `insert` do nosso `subscriptions` q vem do schema, passando os `.values(name, email)`
   - utilizar o returning() para retornar um objeto inteiro

```
import { db } from "../drizzle/client";
import {subscriptions} from "../drizzle/schema/subscriptions"

interface SubscriptionToEventParams {
    name: string;
    email: string;
}

export async function subscribeToEvent({name, email}: SubscriptionToEventParams) {

    const result = await db.insert(subscriptions).values({
        name,
        email
    }).returning()

    const subscriber = result[0]

    return {
        subscriberId: subscriber.id
    }
}
```
   - Chamando na rota de POST de subscription
```
    const {subscriberId } = await subscribeToEvent({name, email})
    return reply.status(201).send({ name, email, subscriberId })

```

4. Segunda funcionalidade √© usando o redis, de acesso ao link
   - Quando o us√∫ario se inscrever ele vai ser redirecionado para uma pagina
   - la ele vai ter um link gerado pelo back-end o seu link de convite
   - E nossa fun√ß√£o nessa rota √© incremetar sempre +1 para o dono do link q foi aberto
   - `const { subscriberId } = request.params` ‚Üí Pega o ID da URL
   - `await accessInviteLink(...)` ‚Üí Chama a fun√ß√£o que registra o acesso
   - `new URL(env.WEB_URL)` ‚Üí Cria uma URL base do frontend
   - `url.searchParams.set("referrer", subscriberId)` ‚Üí Adiciona o ID como query param
   - `reply.redirect(url.toString(), 302)` ‚Üí Redireciona o usu√°rio (redirect tempor√°rio)
   - üß† Fun√ß√£o accessInviteLink
   -  - `interface AccessInviteLinkParams` ‚Üí Define o tipo dos par√¢metros
   -  - `async function accessInviteLink(...)` ‚Üí Fun√ß√£o que registra o clique no convite
   -  - `redis.hincrby(...)` ‚Üí Incrementa +1 no contador daquele subscriberId no Redis
   -  - `"referral:access-count"` ‚Üí Nome da "tabela/hash" no Redis
   -  - `subscriberId` ‚Üí Campo dentro do hash
   -  - `1` 1 ‚Üí Incremento de +1
   - üß© Resum√£o geral (n√≠vel vis√£o de produto)
   -  - Usu√°rio acessa `/invites/:subscriberId`
   -  - Backend registra +1 acesso no Redis
   -  - Backend redireciona pro front com ?referrer=ID


5. Terceira funcionalidade √© buscar quantidade de acessos no link (Redis)
   - Essa funcionalidade serve para mostrar quantas vezes o link de convite foi acessado
   - O backend consulta o Redis e retorna o n√∫mero de cliques daquele usu√°rio
   - `const { subscriberId } = request.params` ‚Üí Pega o ID da URL
   - `await getSubscriberInviteLink(...)` ‚Üí Chama a fun√ß√£o que busca os dados no Redis
   - `return { subscriberId, count }` ‚Üí Retorna o ID + quantidade de acessos
   - üß© Resum√£o geral (n√≠vel vis√£o de produto)
   -  - Usu√°rio acessa `/subscribers/:subscriberId/ranking/clicks`
   -  Backend busca no Redis quantos acessos esse link teve
   -  Backend retorna:
   -  - subscriberId
   -  `count` (quantidade de cliques)

6. Quarta funcionalidade √© inscri√ß√£o com sistema de indica√ß√£o (referrer)
   - Essa funcionalidade permite que um usu√°rio se inscreva usando o link de outra pessoa (indica√ß√£o)
   - Se houver um `referrer`, o sistema registra isso e aumenta o ranking de quem indicou
   - `const { name, email, referrer } = request.body` ‚Üí Pega os dados do corpo da requisi√ß√£o
   - `await subscribeToEvent(...)` ‚Üí Chama a fun√ß√£o que cria a inscri√ß√£o no banco
   - referrer ‚Üí ID de quem indicou (vem da URL do frontend, tipo ?referrer=ID)
   - `reply.status(201).send(...)` ‚Üí Retorna o ID do novo inscrito
   - Usu√°rio se inscreve em /subscriptions
   - Pode vir com ?referrer=ID (indica√ß√£o)
   - Backend cria o usu√°rio no banco
   - Se tiver indica√ß√£o, soma +1 no ranking do indicador no Redis
   - Backend retorna o subscriberId criado 

7. Quinta funcionalidade √© buscar quantidade de convites convertidos (ranking no Redis)
   - Essa funcionalidade serve para mostrar quantas pessoas se cadastraram usando o link de um usu√°rio
   - Aqui usamos um Sorted Set (ranking) no Redis, onde cada usu√°rio tem uma pontua√ß√£o (score)
   - `const { subscriberId } = request.params` ‚Üí Pega o ID da URL
   - `await getSubscriberInviteCount(...)` ‚Üí Chama a fun√ß√£o que busca o score no Redis
   - `return { count }` ‚Üí Retorna a quantidade de convites convertidos
   - üß† Fun√ß√£o getSubscriberInviteCount
   - ‚Üí Fun√ß√£o que busca o total no ranking
   - `redis.zscore(...)` ‚Üí Busca a pontua√ß√£o (score) do usu√°rio no ranking
   - `"referral:ranking"` ‚Üí Nome do Sorted Set no Redis
   - `subscriberId` ‚Üí Membro dentro do ranking
   - ‚Üí `Number.parseInt(count)` ‚Üí Converte o valor retornado (string) para n√∫mero
   - Usu√°rio acessa `/subscribers/:subscriberId/ranking/count`
   - Backend consulta o ranking no Redis
   - Backend retorna:
   - count (quantidade de pessoas que se cadastraram com o link dele)


8 Sexta funcionalidade √© buscar posi√ß√£o no ranking (Redis)
  - Essa funcionalidade serve para mostrar em qual posi√ß√£o o usu√°rio est√° no ranking de convites
  - Aqui usamos um Sorted Set (ranking) ordenado do maior para o menor
  - `const { subscriberId } = request.params` ‚Üí Pega o ID da URL
  - `await getSubscriberRankingPosition(...)` ‚Üí Chama a fun√ß√£o que busca a posi√ß√£o no Redis
  - `return { position }` ‚Üí Retorna a posi√ß√£o do usu√°rio no ranking
  - `redis.zrevrank(...)` ‚Üí Retorna a posi√ß√£o do usu√°rio no ranking (ordem decrescente)
  - `"referral:ranking"` ‚Üí Nome do Sorted Set no Redis
  - `subscriberId `‚Üí Membro dentro do ranking
  - `rank + 1` ‚Üí Ajusta a posi√ß√£o (Redis come√ßa do 0, ent√£o +1)
  - `if (rank == null)` ‚Üí Se n√£o existir no ranking, retorna posi√ß√£o 0
  - Usu√°rio acessa `/subscribers/:subscriberId/ranking/position
  - Backend consulta o ranking no Redis
  - Backend retorna:
  - `position` (posi√ß√£o do usu√°rio no ranking de convites)